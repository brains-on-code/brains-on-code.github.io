<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans|Open+Sans+Condensed:300|Oswald" rel="stylesheet">
    <style type="text/css">

        body {
            margin: 0;
        }

        #content {
            margin: 1em;
        }

        nav {
            font-family: 'Open Sans', Helvetica, Arial, sans-serif; color: #444;
            margin: 0;
            background-color: #009AE8;
        }

        nav h1 {
            margin: 0;
            padding: 1em 1em 0 1em;
            color: white;
        }

        nav p {
            color: white;
            margin: 0;
            padding: 1em;
        }

        p,a,summary {
            font-family: 'Open Sans', Helvetica, Arial, sans-serif; color: #444;
            font-size: 12pt;
            line-height: 24pt;
        }

        h1,h2,h3,h4 {
            margin: 0.7em 0;
            font-weight: bolder;
            font-family: 'Open Sans', Helvetica, Arial, sans-serif;
            color: #444;
        }

        header h3 {
            font-family: 'Oswald', Helvetica, Arial, sans-serif;
            font-weight: normal;
            line-height: 56pt;
            font-size: 24pt;
        }

        h4 {
            font-size: 12pt;
        }

        h4.abstract {
            font-size: 12pt;
            display: inline;
        }

        h4.abstract:after {
            content: ":";
        }

        article {
            margin: 1em;
            border-bottom: 1px solid black;
        }

        ul.authors {
            margin: 0;
            padding: 0;
            text-indent: 0;
        }

        ul.authors li {
            display: inline;
            list-style: none;
        }

        ul.authors li, ul.authors li a {
            font-family: 'Open Sans Condensed';
            font-size: 16pt;
        }

        ul.authors li a {
            color: #009AE8;
            text-decoration: none;
        }

        ul.authors li:not(:last-child):after {
            content: ','
        }

        header h3 {
            margin-bottom: 0;
        }

        header small, header small a {
            font-size: small;
        }

        summary {
            margin-top: 1em;
        }

        nav {

        }

    </style>
    <title>Brains on Code</title>
    <meta name="description" content="Scientific projects concerning program comprehension, Chemnitz University of Technology, Saarland University">
    <meta name="keywords" lang="en" content="Science, fMRI, Programming, Comprehension">
</head>
<body>
    <nav>
        <h1>Brains on Code</h1>
        <p>We are researchers interested in empirical software engineering from Chemnitz, Magdeburg, Saarbrücken, and Raleigh. We conduct behavioral, eye-tracking and neuroimaging studies on program comprehension.</p>
    </nav>
    <div id="content">
        <section>
            <h2>Projects</h2>
            <article>
                <header>
                    <h3 style="float:left">
                        ERC Advanced Grant: BrainsOnCode
                    </h3>
                    <img src="BrainsOnCode-Logo.png" style="height: 75px;margin-left: 2em ">
                </header>
                <ul class="authors" style="clear:both"><li><a href="http://www.infosun.fim.uni-passau.de/se/apel/">Sven Apel</a></li></ul>
                <ul class="resources"> <a href="http://brains-on-code-erc.org">Projects Website: brains-on-code-erc.org</a></ul>
            </article>
            <article>
                <header>
                    <h3>
                        DFG:
                        Neuronale, behaviorale und psychophysiologische Korrelate von Programmverständnis
                    </h3>
                </header>
                <ul class="authors"><li>Andre Brechmann</li>
                    <li><a href="https://www.tu-chemnitz.de/informatik/ST/professur/professor.php.en">Janet Siegmund</a></li>     </ul>
                <ul class="resources"> <a href="https://gepris.dfg.de/gepris/projekt/285612080">Projects Website: https://gepris.dfg.de/gepris/projekt/285612080</a></ul>
            </article>

        </section>

        <section>
            <h2>Papers</h2>
            <article>
                <header>
                    <h3>Program Comprehension and Code Complexity Metrics: An fMRI Study (ICSE 21)</h3>
                </header>
                <ul class="authors">
                    <li>Norman Peitek</li>
                    <li><a href="http://www.infosun.fim.uni-passau.de/se/apel/">Sven Apel</a></li>
                    <li><a href="http://www.chrisparnin.me">Chris Parnin</a></li>
                    <li>Andre Brechmann</li>
                    <li><a href="https://www.tu-chemnitz.de/informatik/ST/professur/professor.php.en">Janet Siegmund</a></li>                    
                </ul>
                <summary>
                    <b>Background:</b> Researchers and practitioners have been using code complexity metrics for decades to predict how developers comprehend a program. While it is plausible and tempting to use them for this purpose, their validity is questionable, since they rely on code properties and rarely consider particularities of human cognition.<br>
                    <b>Aims:</b> We investigate whether and how code complexity metrics reflect difficulty of program comprehension.<br>
                    <b>Method:</b> We conducted a functional magnetic resonance imaging (fMRI) study with 19 participants observing program comprehension of short code snippets at varying complexity levels. We dissected four classes of code complexity metrics and their relationship to neuronal, behavioral, and subjective correlates of program comprehension, overall analyzing more than 41 metrics.<br>
                    <b>Results:</b> While we could corroborate that complexity metrics can—to a limited degree—explain programmers' cognition in program comprehension, fMRI allowed us to gain more insights into <i>why</i> some properties of code can be difficult to process. In particular, the code's textual size drives programmers' attention and vocabulary size burdens programmers' working memory.<br>
                    <b>Conclusion:</b> Our results provide neuro-scientific evidence that supports warnings of prior research questioning the validity of code complexity metrics and reveal factors relevant to program comprehension.<br>
                    <b>uture Work:</b> We outline a number of follow-up experiments investigating fine-grained effects of code complexity and describe possible refinements to complexity metrics.<br>
                </summary>
                <h4>Resources</h4>
                <ul class="resources">
                    <li><a href="https://github.com/brains-on-code/fMRI-complexity-metrics-icse2021">Replication Package</a></li>
                </ul>
            </article>

            <article>
            <header>
                <h3>REyeker: Remote Eye Tracker (EMIP 2021)</h3>
            </header>
            <ul class="authors">
                <li><a href="https://github.com/Sonaion">Jonas Mucke</a></li>   
                <li>Marc Schwarzkopf</a></li>
                <li><a href="https://www.tu-chemnitz.de/informatik/ST/professur/professor.php.en">Janet Siegmund</a></li>                    
            </ul>
            <summary>
                Eye tracking allows us to shed light on how developers read and
                understand source code and how that is linked to cognitive processes. However, studies with eye trackers are usually tied to a
                laboratory, requiring to observe participants one at a time, which
                is especially challenging in the current pandemic. To allow for safe
                and parallel observation, we present our tool REyeker, which allows
                researchers to observe developers remotely while they understand
                source code from their own computer without having to directly
                interact with the experimenter. The original image is blurred to
                distort text regions and disable legibility, requiring participants to
                click on areas of interest to deblur them to make them readable.
                While REyeker naturally can only track eye movements to a limited degree, it allows researchers to get a basic understanding of
                developers’ reading behavior.
            </summary>
            <h4>Resources</h4>
            <ul class="resources">
                <li><a href="https://www.tu-chemnitz.de/informatik/ST/publications/papers/REyeker.pdf">Paper</a></li>
                <li><a href="https://github.com/brains-on-code/REyeker">GitHub</a></li>
            </ul>
            </article>
            
            <article>
                <header>
                    <h3>Mastering Variation in Human Studies: The Role of Aggregation (TOSEM)</h3>
                </header>
                <ul class="authors">
                    <li><a href="https://www.tu-chemnitz.de/informatik/ST/professur/professor.php.en">Janet Siegmund</a></li> 
                    <li>Norman Peitek</li>
                    <li><a href="http://www.infosun.fim.uni-passau.de/se/apel/">Sven Apel</a></li>
                    <li><a href="https://sws.informatik.uni-leipzig.de">Norbert Siegmund</a></li>
                </ul>
                <summary>
                    The human factor is prevalent in empirical software engineering research. However, human studies often do not use the full potential of analysis methods by combining analysis of individual tasks and participants with an analysis that aggregates results over tasks and/or participants. This may hide interesting insights of tasks and participants and may lead to false conclusions by overrating or underrating single-task or participant performance. We show that studying multiple levels of aggregation of individual tasks and participants allows researchers to have both, insights from individual variations as well as generalized, reliable conclusions based on aggregated data. Our literature survey revealed that most human studies perform either a fully aggregated analysis or an analysis of individual tasks. To show that there is important, non-trivial variation when including human participants, we reanalyze 12 published empirical studies, thereby changing the conclusions or making them more nuanced. Moreover, we demonstrate the effects of different aggregation levels by answering a novel research question on published sets of fMRI data. We show that, when more data are aggregated, the results become more accurate. This proposed technique can help researchers to find a sweet spot in the tradeoff between cost of a study and reliability of conclusions.
                </summary>
                <h4>Resources</h4>
                <ul class="resources">
                    <li><a href="https://github.com/brains-on-code/conducting-and-analyzing-human-studies">Replication Package</a></li>
                    <li><a href="https://www.se.cs.uni-saarland.de/publications/docs/SPA+20.pdf">Paper, PDF</a></li>
                </ul>
            </article>
            
            <article>
                <header>
                    <h3>What Drives the Reading Order of Programmers? An Eye Tracking Study (ICPC 20)</h3>
                </header>
                <ul class="authors">
                    <li>Norman Peitek</li>
                    <li><a href="https://www.tu-chemnitz.de/informatik/ST/professur/professor.php.en">Janet Siegmund</a></li>                    
                    <li><a href="http://www.infosun.fim.uni-passau.de/se/apel/">Sven Apel</a></li>
                </ul>
                <summary>
                    <b>Background:</b> The way how programmers comprehend source code depends on several factors, including the source code itself and the programmer. Recent studies showed that novice programmers tend to read source code more like natural language text, whereas experts tend to follow the program execution flow. But, it is unknown how the <i>linearity of source code</i> and the comprehension strategy influence programmers' <i>linearity of reading order</i>.<br>
                    <b>Objective:</b> We replicate two previous studies with the aim of additionally providing empirical evidence on the influencing effects of linearity of source code and programmers' comprehension strategy on linearity of reading order.<br>
                    <b>Methods:</b> To understand the effects of linearity of source code on reading order, we conducted a non-exact replication of studies by Busjahn et al. and Peachock et al., which compared the reading order of novice and expert programmers. Like the original studies, we used an eye-tracker to record the eye movements of participants (12 novice and 19 intermediate programmers).<br>
                    <b>Results:</b> In line with Busjahn et al. (but different from Peachock et al.), we found that experience modulates the reading behavior of participants. However, the linearity of source code has an even stronger effect on reading order than experience, whereas the comprehension strategy has a minor effect.<br>
                    <b>Implications:</b> Our results demonstrate that studies on the reading behavior of programmers must carefully select source code snippets to control the influence of confounding factors. Furthermore, we identify a need for further studies on how programmers should structure source code to align it with their natural reading behavior to ease program comprehension.<br>
                </summary>
                <h4>Resources</h4>
                <ul class="resources">
                    <li><a href="https://github.com/brains-on-code/eyetracking-linearity-replication">Replication Package</a></li>
                    <li><a href="https://www.se.cs.uni-saarland.de/publications/docs/PSA20.pdf">Paper, PDF</a></li>
                </ul>
            </article>
            
            <article>
                <header>
                    <h3>Indentation: Simply a Matter of Style or Support for Program Comprehension? (ICPC 19 - Replication Track)</h3>
                </header>
                <ul class="authors">
                    <li>Jennifer Bauer</li>
                    <li><a href="https://www.tu-chemnitz.de/informatik/ST/professur/professor.php.en">Janet Siegmund</a></li>                    
                    <li>Norman Peitek</li>
                    <li><a href="http://www.cessor.de">Johannes C. Hofmeister</a></li>
                    <li><a href="https://www.se.cs.uni-saarland.de/apel/">Sven Apel</a></li>
                </ul>
                <summary>
                    An early study showed that indentation is not a matter of style, but provides actual support for program comprehension. In this paper, we present a non-exact replication of this study. Our aim is to provide empirical evidence for the suggested level of indentation made by many style guides. Following Miara and others, we also included the perceived difficulty, and we extended the original design to gain additional insights into the influence of indentation on visual effort by employing an eye-tracker. In the course of our study, we asked 22~participants to calculate the output of Java code snippets with different levels of indentation, while we recorded their gaze behavior. We could not find any indication that the indentation levels affect program comprehension or visual effort, so we could not replicate the findings of Miara and others. Nevertheless, our modernization of the original experiment design are a promising starting point for future studies in this field.
                </summary>
                <h4>Resources</h4>
                <ul class="resources">
                    <li><a href="https://github.com/brains-on-code/indentation">Replication Package</a></li>
                    <li><a href="https://www.infosun.fim.uni-passau.de/publications/docs/Bauer19.pdf">Paper, PDF</a></li>
                </ul>
            </article>
            
            <article>
                <header>
                    <h3>CodersMUSE: Multi-Modal Data Exploration of Program-Comprehension Experiments (ICPC 19 - Tool Track)</h3>
                </header>
                <ul class="authors">
                    <li>Norman Peitek</li>
                    <li><a href="https://www.se.cs.uni-saarland.de/apel/">Sven Apel</a></li>
                    <li>Andre Brechmann</li>
                    <li><a href="http://www.chrisparnin.me">Chris Parnin</a></li>
                    <li><a href="https://www.tu-chemnitz.de/informatik/ST/professur/professor.php.en">Janet Siegmund</a></li>
                </ul>
                <summary>
                    Program comprehension is a central cognitive process in programming and has been in the focus of researchers for decades, but is still not thoroughly unraveled. Multi-modal measurement methods are a way to gain a more holistic understanding of program comprehension. However, there is no proper tool support that lets researchers explore synchronized, conjoint multi-modal data, specifically designed for the needs in software engineering. In this paper, we present CodersMUSE, a prototype implementation that aims to satisfy this crucial need.
                </summary>
                <h4>Resources</h4>
                <ul class="resources">
                    <li><a href="https://github.com/brains-on-code/CodersMUSE">Tool Website: Open-Source Code, Sample Data, Demo Video</a></li>
                    <li><a href="https://www.infosun.fim.uni-passau.de/publications/docs/Peitek19.pdf">Paper, PDF</a></li>
                </ul>
            </article>

            <article>
                <header>
                    <h3>A Look into Programmers’ Heads (TSE)</h3>
                </header>
                <ul class="authors">
                    <li>Norman Peitek</li>
                    <li><a href="https://www.tu-chemnitz.de/informatik/ST/professur/professor.php.en">Janet Siegmund</a></li>                    
                    <li><a href="https://www.se.cs.uni-saarland.de/apel/">Sven Apel</a></li>
                    <li><a href="http://www.cs.cmu.edu/~ckaestne/">Christian Kaestner</a></li>
                    <li><a href="http://www.chrisparnin.me">Chris Parnin</a></li>
                    <li>Anja Bethmann</li>
                    <li>Thomas Leich</li>
                    <li>Gunter Saake</li>
                    <li>Andre Brechmann</li>
                </ul>
                <summary>
                    <b>Abstract:</b> Program comprehension is an important, but hard to measure cognitive process. This makes it difficult to provide suitable
programming languages, tools, or coding conventions to support developers in their everyday work. Here, we explore whether
<i>functional magnetic resonance imaging (fMRI)</i> is feasible for soundly measuring program comprehension. To this end, we observed 17
participants inside an fMRI scanner while they were comprehending source code. The results show a clear, distinct activation of five
brain regions, which are related to working memory, attention, and language processing, which all fit well to our understanding of
program comprehension. Furthermore, we found reduced activity in the default mode network, indicating the cognitive effort necessary
for program comprehension. We also observed that familiarity with Java as underlying programming language reduced cognitive effort
during program comprehension. To gain confidence in the results and the method, we replicated the study with 11 new participants and
largely confirmed our findings. Our results encourage us and, hopefully, others to use fMRI to observe programmers and, in the long
run, answer questions, such as: How should we train programmers? Can we train someone to become an excellent programmer? How
effective are new languages and tools for program comprehension?
                </summary>
                <h4>Resources</h4>
                <ul class="resources">                    
                    <li><a href="https://doi.org/10.1109/TSE.2018.2863303">DOI: 10.1109/TSE.2018.2863303</a></li>
                    <li><a href="https://www.infosun.fim.uni-passau.de/publications/docs/PSA+18tse.pdf">Paper - A Look into Programmers’ Heads, PDF, 2MB</a></li>
                </ul>
            </article>

            <article>
                <header>
                    <h3>Simultaneous Measurement of Program Comprehension with fMRI and Eye Tracking: A Case Study (ESEM 18)</h3>
                </header>
                <ul class="authors">
                    <li>Norman Peitek</li>
                    <li><a href="https://www.tu-chemnitz.de/informatik/ST/professur/professor.php.en">Janet Siegmund</a></li>                    
                    <li><a href="http://www.chrisparnin.me">Chris Parnin</a></li>
                    <li><a href="https://www.se.cs.uni-saarland.de/apel/">Sven Apel</a></li>
                    <li><a href="http://www.cessor.de">Johannes C. Hofmeister</a></li>
                    <li>Andre Brechmann</li>
                </ul>
                <summary>
                    <b>Background</b> Researchers have recently started using functional magnetic resonance imaging (fMRI) to validate decades-old programcomprehension models. While fMRI helps us to understand neuronal correlates of cognitive processes during program comprehension, its comparatively low temporal resolution (i.e., seconds)
cannot capture the fast cognitive subprocesses (i.e., milli seconds).</br>
                    <b>Aims</b> To increase the explanatory power of fMRI measurement of programmers, we are exploring the feasibility of adding simultaneous eye tracking to the fMRI measurement. By observing programmers with two complementary methods, we aim at obtaining
a more holistic understanding of program comprehension.</br>
                    <b>Method</b> We conducted a controlled fMRI experiment of 22 student participants with simultaneous eye tracking.</br>
                    <b>Results</b> We could successfully capture fMRI and eye-tracking data, although with some limitations, including spatial imprecision and
a negligible drift. The biggest issue that we experienced is the partial loss of data, such that for only 10 participants, we could
collect a complete set of high-precision eye-tracking data. Since some participants of fMRI studies show excessive head motion, the
proportion of full and high-quality data on fMRI and eye tracking is rather low. Still, the remaining data allowed us to confrm our
prior hypothesis of semantic recall during program comprehension, which was not possible with fMRI alone.</br>
                    <b>Conclusions</b> Simultaneous measurement of program comprehension with fMRI and eye tracking is feasible and promising. By adding
simultaneous eye tracking to our fMRI study framework, we can conduct more fne-grained fMRI analyses, which in turn helps us
to understand programmer behavior better.
                </summary>
                <h4>Resources</h4>
                <ul class="resources">
                    <li><a href="https://github.com/brains-on-code/simultaneous-fmri-and-eyetracking">Replication Package</a></li>
                    <li><a href="https://www.infosun.fim.uni-passau.de/publications/docs/PSP+18b.pdf">Paper - Simultaneous Measurement of Program Comprehension with fMRI and Eye Tracking: A Case Study, PDF, 6MB</a></li>
                </ul>
            </article>
            
            <article>
                <header>
                    <h3>Shorter Identifier Names Take Longer To Comprehend (EMSE 18)</h3>
                </header>
                <ul class="authors">
                    <li><a href="http://www.cessor.de">Johannes C. Hofmeister</a></li>
                    <li><a href="https://www.tu-chemnitz.de/informatik/ST/professur/professor.php.en">Janet Siegmund</a></li>
                    <li><a href="http://www.psychologie.uni-heidelberg.de/ae/allg/mitarb/dh/">Daniel V. Holt</a></li>
                </ul>
                <summary>
                    <h4 class="abstract">Abstract</h4>
                    This article extends <a href="https://doi.org/10.1109/SANER.2017.7884623">Hofmeister, Siegmund, &amp; Holt (2017) @ SANER17, see below</a>. We analyze and discuss participants’ visual focus. The data were obtained in the original study using a restricted focus viewer, called the "letterbox", which limited the visible code to 7 lines at once.
                </summary>
                <h4>Resources</h4>
                <ul class="resources">
                    <li><a href="https://doi.org/10.1007%2Fs10664-018-9621-x">DOI: 10.1007/2Fs10664-018-9621-x</a></li>
                    <li><a href="https://github.com/brains-on-code/peter">Replication Package</a></li>
                    <li><a href="https://github.com/brains-on-code/shorter-identifier-names">Results</a></li>
                </ul>
            </article>

            <article>
                <header>
                    <h3>Shorter Identifier Names Take Longer To Comprehend (SANER 17)</h3>
                </header>
                <ul class="authors">
                    <li><a href="http://www.cessor.de">Johannes C. Hofmeister</a></li>
                    <li><a href="https://www.tu-chemnitz.de/informatik/ST/professur/professor.php.en">Janet Siegmund</a></li>
                    <li><a href="http://www.psychologie.uni-heidelberg.de/ae/allg/mitarb/dh/">Daniel V. Holt</a></li>
                </ul>
                <summary>
                    <h4 class="abstract">Abstract</h4>
                    Developers spend the majority of their time comprehending code, a process in which identifier names play a key role. Although many identifier naming styles exist, they often lack an empirical basis and it is not quite clear whether short or long identifier names facilitate comprehension. In this paper, we investigate the effect of different identifier naming styles (letters, abbreviations, words) on program comprehension, and whether these effects arise because of their length or their semantics. We conducted an experimental study with <b>72 professional C# developers</b>, who looked for defects in source-code snippets. We used a within-subjects design, such that each developer saw all three versions of identifier naming styles and we measured the time it took them to find a defect. <b>We found that words lead to, on average, 19% faster comprehension speed compared to letters and abbreviations, but we did not find a significant difference in speed between letters and abbreviations.</b> The results of our study suggest that defects in code are more difficult to detect when code contains only letters and abbreviations. Words as identifier names facilitate program comprehension and can help to save costs and improve software quality.
                </summary>
                <h4>Resources</h4>
                <ul class="resources">
                    <li><a href="https://doi.org/10.1109/SANER.2017.7884623">DOI: 10.1109/SANER.2017.7884623</a></li>
                    <li><a href="shorter-identifier-names.pdf">Preprint - Shorter Identifier Names Take Longer To Comprehend, PDF, 327kb</a></li>
                    <li><a href="https://github.com/brains-on-code/peter">Replication Package</a></li>
                    <li><a href="https://github.com/brains-on-code/shorter-identifier-names">Results</a></li>
                </ul>
            </article>

            <article>
                <header>
                    <h3>Measuring Neural Efficiency of Program Comprehension (ESEC/FSE 17)</h3>
                </header>
                <ul class="authors">
                    <li><a href="https://www.tu-chemnitz.de/informatik/ST/professur/professor.php.en">Janet Siegmund</a></li>
                    <li>Norman Peitek</li>
                    <li><a href="http://www.chrisparnin.me">Chris Parnin</a></li>
                    <li><a href="https://www.se.cs.uni-saarland.de/apel/">Sven Apel</a></li>
                    <li><a href="http://www.cessor.de">Johannes Hofmeister</a></li>
                    <li><a href="http://www.cs.cmu.edu/~ckaestne/">Christian Kaestner</a></li>
                    <li><a href="http://www.andrewbegel.com">Andrew Begel</a></li>
                    <li>Anja Bethmann</li>
                    <li>Andre Brechmann</li>
                </ul>
                <summary>
                    <h4 class="abstract">Abstract</h4>
                    Most modern software programs cannot be understood in their entirety by a single programmer. Instead, programmers must rely on a set of cognitive processes that aid in seeking, filtering, and shaping relevant information for a given programming task. Several theories have been proposed to explain these processes, such as <i>beacons</i>, for locating relevant code, and <i>plans</i>, for encoding cognitive models. However, these theories are decades old and lack validation with modern cognitive-neuroscience methods. In this paper, we report on a study using functional magnetic resonance imaging (fMRI) with 11 participants who performed program comprehension tasks. We manipulated experimental conditions related to beacons and layout to isolate specific cognitive processes related to bottom-up comprehension and comprehension based on semantic cues. We found evidence of semantic chunking during bottom-up comprehension and lower activation of brain areas during comprehension based on semantic cues, confirming that beacons ease comprehension.
                </summary>
                <h4>Resources</h4>
                <ul class="resources">
                    <li><a href="https://doi.org/10.1145/3106237.3106268">DOI: 10.1145/3106237.3106268</a></li>
                    <li><a href="https://www.infosun.fim.uni-passau.de/publications/docs/SPP+17.pdf">Paper - Measuring Neural Efficiency of Program Comprehension, PDF, 1MB</a></li>
                    <li><a href="https://github.com/brains-on-code/paper-esec-fse-2017">Replication Package</a></li>
                </ul>
            </article>
        </section>

        <section>
            <h1>Empirical Research of Program Comprehension</h1>
            <ul>
                <li>
                    <a href="http://www.infosun.fim.uni-passau.de/se/janet/">Further Resources</a>
                </li>
            </ul>
        </section>
    </div>

</body>
</html>


